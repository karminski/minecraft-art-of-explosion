<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的世界模拟游戏</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
        }

        #debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            min-width: 160px;
            color: #00ff00;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 5px;
            pointer-events: none;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        .inventory-slot {
            width: 64px;
            height: 64px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .inventory-slot.selected {
            background-color: rgba(255, 255, 0, 0.3);
            transform: scale(1.3);
        }

        .inventory-item {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div id="info">
        控制说明:<br>
        WASD - 移动<br>
        鼠标 - 转向<br>
        空格 - 跳跃<br>
        左键 - 挖方块<br>
        右键 - 放方块<br>
        按M锁定鼠标<br>
        1-5 - 切换道具<br>
        <br>
        调试按键:<br>
        R - 重置所有方块<br>
        C - 清空场景<br>
        V - 输出场景对象
    </div>
    <div id="debug-panel">
        FPS: 0<br>
        Frame Time: 0.00ms<br>
        Camera Position:<br>
        X: 0.00<br>
        Y: 0.00<br>
        Z: 0.00<br>
        Look Direction:<br>
        X: 0.00<br>
        Y: 0.00<br>
        Z: 0.00
    </div>
    <div id="inventory"></div>
    <canvas id="crosshair" width="20" height="20"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const textureLoader = new THREE.TextureLoader();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 设置相机位置
        camera.position.y = 10;
        camera.position.z = 20;

        // 创建光源
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // 加载天空纹理
        const skyTexture = textureLoader.load('assets/images/sky.jpg');

        // 创建天空球
        function createSky() {
            const geometry = new THREE.SphereGeometry(800, 128, 128); // 半径足够大，包围整个场景
            const material = new THREE.MeshBasicMaterial({
                map: skyTexture,
                side: THREE.BackSide // 只渲染球体的内侧
            });
            const sky = new THREE.Mesh(geometry, material);
            sky.isSky = true; // 添加标记以便于识别
            scene.add(sky);
            return sky;
        }

        const sky = createSky();

        // 方块类型和纹理
        const blockTypes = {
            air: 0,
            grass: 1,
            dirt: 2,
            stone: 3,
            tree: 4,
            leaves: 5
        };

        // 加载纹理
        const textures = {
            grass: textureLoader.load('assets/images/grass.png'),
            dirt: textureLoader.load('assets/images/dirt.png'),
            stone: textureLoader.load('assets/images/stone.png'),
            tree: textureLoader.load('assets/images/tree.png'),
            leaves: textureLoader.load('assets/images/leaves.png')
        };

        // 创建方块材质
        const materials = {
            grass: new THREE.MeshPhongMaterial({ map: textures.grass, color: 0x7cba34 }),
            dirt: new THREE.MeshPhongMaterial({ map: textures.dirt, color: 0x8b4513 }),
            stone: new THREE.MeshPhongMaterial({ map: textures.stone, color: 0x808080 }),
            tree: new THREE.MeshPhongMaterial({ map: textures.tree, color: 0x8b4513 }),
            leaves: new THREE.MeshPhongMaterial({ map: textures.leaves, color: 0x32cd32, transparent: true, opacity: 0.8 })
        };

        // 世界大小
        const worldSize = 50;

        // 保存所有创建的方块
        const blockReferences = [];

        // 修改createBlock函数以保存引用
        function createBlock(x, y, z, type) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = materials[Object.keys(blockTypes).find(key => blockTypes[key] === type)];
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x + 0.5, y + 0.5, z + 0.5);
            cube.type = type;
            cube.blockX = x;
            cube.blockY = y;
            cube.blockZ = z;
            scene.add(cube);
            
            // 保存引用到数组
            blockReferences.push(cube);
            
            return cube;
        }

        // 创建世界
        const world = [];
        for (let x = 0; x < worldSize; x++) {
            world[x] = [];
            for (let y = 0; y < worldSize; y++) {
                world[x][y] = [];
                for (let z = 0; z < worldSize; z++) {
                    world[x][y][z] = blockTypes.air;
                }
            }
        }

        // 生成地形
        function generateTerrain() {
            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    // 地面层
                    const height = Math.floor(Math.random() * 3) + 1;
                    for (let y = 0; y < height; y++) {
                        if (y === height - 1) {
                            world[x][y][z] = blockTypes.grass;
                        } else if (y === height - 2) {
                            world[x][y][z] = blockTypes.dirt;
                        } else {
                            world[x][y][z] = blockTypes.stone;
                        }
                    }
                }
            }
        }

        // 生成树
        function generateTree(x, z) {
            const height = Math.floor(Math.random() * 3) + 4;
            // 树干
            for (let y = 1; y < height; y++) {
                world[x][y][z] = blockTypes.tree;
            }
            // 树冠
            const crownSize = Math.floor(Math.random() * 2) + 2;
            for (let dx = -crownSize; dx <= crownSize; dx++) {
                for (let dz = -crownSize; dz <= crownSize; dz++) {
                    for (let y = height; y < height + crownSize; y++) {
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        if (distance < crownSize && Math.random() > 0.3) {
                            world[x + dx][y][z + dz] = blockTypes.leaves;
                        }
                    }
                }
            }
        }

        // 随机生成树
        function generateTrees() {
            const treeCount = Math.floor(Math.random() * 5) + 1;
            for (let i = 0; i < treeCount; i++) {
                const x = Math.floor(Math.random() * worldSize);
                const z = Math.floor(Math.random() * worldSize);
                if (world[x][0][z] === blockTypes.grass) {
                    generateTree(x, z);
                }
            }
        }

        // 渲染世界
        function renderWorld() {
            for (let x = 0; x < worldSize; x++) {
                for (let y = 0; y < worldSize; y++) {
                    for (let z = 0; z < worldSize; z++) {
                        if (world[x][y][z] !== blockTypes.air) {
                            createBlock(x, y, z, world[x][y][z]);
                        }
                    }
                }
            }
        }

        // 初始化世界
        generateTerrain();
        generateTrees();
        renderWorld();

        // 玩家控制
        const player = {
            position: new THREE.Vector3(5, 2, 5),
            rotation: new THREE.Vector2(0, 0),
            speed: 0.1,
            jumpSpeed: 0.3,
            isJumping: false,
            gravity: 0.005,
            velocity: new THREE.Vector3(0, 0, 0)
        };

        // 鼠标控制
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;
        let isRightMouseDown = false;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) {
                isMouseDown = true;
            } else if (event.button === 2) {
                isRightMouseDown = true;
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isMouseDown = false;
            } else if (event.button === 2) {
                isRightMouseDown = false;
            }
        });

        // 键盘控制
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // 鼠标锁定
        let mouseLock = false;
        document.addEventListener('keydown', (event) => {
            if (event.key === 'm' && !mouseLock) {
                mouseLock = true;
                document.body.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            mouseLock = document.pointerLockElement === document.body;
        });

        document.addEventListener('mousemove', (event) => {
            if (mouseLock) {
                const deltaX = event.movementX;
                const deltaY = event.movementY;

                // 修改后的旋转计算
                player.rotation.y -= deltaX * 0.002;
                // 将角度限制在 -π 到 π 之间
                player.rotation.y = ((player.rotation.y + Math.PI) % (Math.PI * 2)) - Math.PI;

                player.rotation.x -= deltaY * 0.002;
                player.rotation.x = THREE.MathUtils.clamp(player.rotation.x, -Math.PI / 2, Math.PI / 2);

                // 使用四元数直接累积旋转
                const deltaQuaternion = new THREE.Quaternion()
                    .setFromAxisAngle(new THREE.Vector3(0, 1, 0), -deltaX * 0.002) // Y轴旋转
                    .multiply(
                        new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -deltaY * 0.002) // X轴旋转
                    );
                camera.quaternion.multiply(deltaQuaternion).normalize();
            }
        });

        // 碰撞检测
        function checkCollision(position, direction) {
            const x = Math.floor(position.x + direction.x * 0.5);
            const y = Math.floor(position.y + direction.y * 0.5);
            const z = Math.floor(position.z + direction.z * 0.5);

            if (x >= 0 && x < worldSize && y >= 0 && y < worldSize && z >= 0 && z < worldSize) {
                return world[x][y][z] !== blockTypes.air;
            }
            return true;
        }

        // 更新相机位置
        function updateCamera() {
            // 重力
            if (!checkCollision(player.position, new THREE.Vector3(0, -1, 0))) {
                player.velocity.y -= player.gravity;
            } else {
                player.velocity.y = 0;
                player.isJumping = false;
            }

            // 跳跃
            if (keys[' '] && !player.isJumping && !checkCollision(player.position, new THREE.Vector3(0, -0.1, 0))) {
                player.velocity.y = player.jumpSpeed;
                player.isJumping = true;
            }

            // 移动
            const moveSpeed = player.speed;
            let moveX = 0;
            let moveZ = 0;

            if (keys['w']) moveZ -= 1;
            if (keys['s']) moveZ += 1;
            if (keys['a']) moveX -= 1;
            if (keys['d']) moveX += 1;

            const direction = new THREE.Vector3(moveX, 0, moveZ).normalize();
            const rotateMatrix = new THREE.Matrix4().makeRotationY(player.rotation.y);
            direction.applyMatrix4(rotateMatrix);

            if (!checkCollision(player.position, direction)) {
                player.velocity.x = direction.x * moveSpeed;
                player.velocity.z = direction.z * moveSpeed;
            } else {
                player.velocity.x = 0;
                player.velocity.z = 0;
            }

            // 更新位置
            player.position.x += player.velocity.x;
            player.position.y += player.velocity.y;
            player.position.z += player.velocity.z;

            // 使用四元数更新相机方向
            const quaternion = new THREE.Quaternion()
                .setFromEuler(new THREE.Euler(
                    player.rotation.x,
                    player.rotation.y,
                    0,
                    'YXZ' // 保持旋转顺序一致
                ));
            camera.quaternion.copy(quaternion);

            // 更新相机位置保持不变
            camera.position.copy(player.position);
        }

        // 添加性能优化辅助函数
        let lastRaycastTime = 0;
        const raycastInterval = 100; // 每100毫秒检测一次

        let isBreakingBlock = false;
        let isPlacingBlock = false;
        const blockActionCooldown = 250; // 操作冷却时间(毫秒)

        // 高亮效果函数 - 添加了节流和范围优化
        function highlightBlock() {
            // 先重置所有方块
            blockReferences.forEach(block => {
                if (block.isHighlighted) {
                    block.material = block.originalMaterial;
                    block.isHighlighted = false;
                }
            });
            
            const raycaster = new THREE.Raycaster();
            // 设置射线检测的长度为3个方块长度
            raycaster.far = 3;
            raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
            
            // 优化：只检测可能在视野范围内的方块
            const visibleBlocks = blockReferences.filter(block => {
                const distance = camera.position.distanceTo(block.position);
                return distance < 5; // 只检测5个单位距离内的方块
            });
            
            const intersects = raycaster.intersectObjects(visibleBlocks);
            
            if (intersects.length > 0) {
                const block = intersects[0].object;
                
                // 保存原始材质
                if (!block.originalMaterial) {
                    block.originalMaterial = block.material.clone();
                }
                
                // 创建新的高亮材质 - 基于原始材质但添加发光效果
                const highlightMaterial = block.originalMaterial.clone();
                
                // 添加发光效果（仅对MeshPhongMaterial和MeshStandardMaterial有效）
                if (highlightMaterial.emissive) {
                    highlightMaterial.emissive.set(0xffff00); // 黄色发光
                    highlightMaterial.emissiveIntensity = 0.1; // 降低发光强度为0.1
                }
                
                // 应用高亮材质
                block.material = highlightMaterial;
                block.isHighlighted = true;
            }
        }

        // 修改挖方块功能，添加防抖动机制
        function breakBlockWithDebounce() {
            if (!isBreakingBlock) {
                isBreakingBlock = true;
                
                const raycaster = new THREE.Raycaster();
                // 设置射线检测的长度为3个方块长度
                raycaster.far = 3;
                raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
                
                // 只检测视野范围内的方块
                const visibleBlocks = blockReferences.filter(block => {
                    const distance = camera.position.distanceTo(block.position);
                    return distance < 5;
                });
                
                const intersects = raycaster.intersectObjects(visibleBlocks);

                if (intersects.length > 0) {
                    const block = intersects[0].object;
                    const x = block.blockX;
                    const y = block.blockY;
                    const z = block.blockZ;

                    if (x >= 0 && x < worldSize && y >= 0 && y < worldSize && z >= 0 && z < worldSize) {
                        world[x][y][z] = blockTypes.air;
                        scene.remove(block);
                        // 从引用数组中移除
                        const index = blockReferences.indexOf(block);
                        if (index > -1) {
                            blockReferences.splice(index, 1);
                        }
                    }
                }
                
                // 添加冷却时间
                setTimeout(() => {
                    isBreakingBlock = false;
                }, blockActionCooldown);
            }
        }

        // 修改放方块功能，添加防抖动机制
        function placeBlockWithDebounce() {
            if (!isPlacingBlock) {
                isPlacingBlock = true;
                
                const raycaster = new THREE.Raycaster();
                // 设置射线检测的长度为3个方块长度
                raycaster.far = 3;
                raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
                
                // 只检测视野范围内的方块
                const visibleBlocks = blockReferences.filter(block => {
                    const distance = camera.position.distanceTo(block.position);
                    return distance < 5;
                });
                
                const intersects = raycaster.intersectObjects(visibleBlocks);

                if (intersects.length > 0) {
                    const block = intersects[0].object;
                    const point = intersects[0].point;
                    const normal = intersects[0].face.normal;

                    const x = Math.floor(point.x + normal.x * 0.5);
                    const y = Math.floor(point.y + normal.y * 0.5);
                    const z = Math.floor(point.z + normal.z * 0.5);

                    if (x >= 0 && x < worldSize && y >= 0 && y < worldSize && z >= 0 && z < worldSize && world[x][y][z] === blockTypes.air) {
                        world[x][y][z] = blockTypes.stone;
                        createBlock(x, y, z, blockTypes.stone);
                    }
                }
                
                // 添加冷却时间
                setTimeout(() => {
                    isPlacingBlock = false;
                }, blockActionCooldown);
            }
        }

        // 移除测试按键，只保留必要的键盘事件处理程序
        document.addEventListener('keydown', (event) => {
            if (event.key >= '1' && event.key <= '5') {
                const index = parseInt(event.key) - 1;
                if (index >= 0 && index < inventory.items.length) {
                    inventory.selectedIndex = index;
                    updateInventoryUI();
                }
            } else if (event.key === 'm' && !mouseLock) {
                mouseLock = true;
                document.body.requestPointerLock();
            }
        });

        // 道具栏功能
        const inventory = {
            items: [
                { name: 'pickaxe', texture: 'assets/images/pickaxe.png' },
                { name: 'tnt', texture: 'assets/images/tnt-side.jpg' },
                { name: 'empty', texture: '' },
                { name: 'empty', texture: '' },
                { name: 'empty', texture: '' }
            ],
            selectedIndex: 0
        };

        // 创建道具栏
        function createInventoryUI() {
            const inventoryElement = document.getElementById('inventory');
            inventoryElement.innerHTML = '';

            inventory.items.forEach((item, index) => {
                const slotElement = document.createElement('div');
                slotElement.className = 'inventory-slot';
                if (index === inventory.selectedIndex) {
                    slotElement.classList.add('selected');
                }

                if (item.texture) {
                    const itemElement = document.createElement('img');
                    itemElement.src = item.texture;
                    itemElement.className = 'inventory-item';
                    slotElement.appendChild(itemElement);
                }

                slotElement.addEventListener('click', () => {
                    inventory.selectedIndex = index;
                    updateInventoryUI();
                });

                inventoryElement.appendChild(slotElement);
            });
        }

        // 更新道具栏UI
        function updateInventoryUI() {
            const slots = document.querySelectorAll('.inventory-slot');
            slots.forEach((slot, index) => {
                slot.classList.remove('selected');
                if (index === inventory.selectedIndex) {
                    slot.classList.add('selected');
                }
            });
        }

        // 使用更高效的 FPS 计算方法
        let lastFrameTime = performance.now();
        let frameTime = 0;

        // 添加十字准星
        const crosshairCanvas = document.getElementById('crosshair');
        const crosshairCtx = crosshairCanvas.getContext('2d');
        crosshairCtx.beginPath();
        crosshairCtx.moveTo(10, 0);
        crosshairCtx.lineTo(10, 20);
        crosshairCtx.moveTo(0, 10);
        crosshairCtx.lineTo(20, 10);
        crosshairCtx.strokeStyle = 'white';
        crosshairCtx.stroke();

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // 计算帧时间和 FPS
            frameTime = currentTime - lastFrameTime;
            const fps = Math.round(1000 / frameTime);
            lastFrameTime = currentTime;

            updateCamera();
            
            // 优化：节流高亮方块的射线检测
            if (currentTime - lastRaycastTime > raycastInterval) {
                highlightBlock();
                lastRaycastTime = currentTime;
            }

            // 获取相机朝向向量
            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);

            // 更新调试面板
            const debugPanel = document.getElementById('debug-panel');
            debugPanel.innerHTML =
                `FPS: ${fps}<br>` +
                `Frame Time: ${frameTime.toFixed(2)}ms<br>` +
                `Camera Position:<br>` +
                `X: ${camera.position.x.toFixed(2)}<br>` +
                `Y: ${camera.position.y.toFixed(2)}<br>` +
                `Z: ${camera.position.z.toFixed(2)}<br>` +
                `Look Direction:<br>` +
                `X: ${lookDirection.x.toFixed(2)}<br>` +
                `Y: ${lookDirection.y.toFixed(2)}<br>` +
                `Z: ${lookDirection.z.toFixed(2)}`;

            // 使用防抖动版本的方块操作
            if (isMouseDown) {
                breakBlockWithDebounce();
            }

            if (isRightMouseDown) {
                placeBlockWithDebounce();
            }

            renderer.render(scene, camera);
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始化道具栏
        createInventoryUI();

        // 开始动画循环
        animate();
    </script>
</body>

</html>
